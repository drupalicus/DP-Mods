<?php
// $Id$

/**
 * @file
 * Create complex, repeating groups of CCK fields that work in unison.
 */

function content_podgroup_help($path, $arg) {
  switch ($path) {
    case 'admin/help#content_podgroup':
      return t('The fields in a Standard group are independent of each other and each can have either single or multiple values. The fields in a Multigroup are treated as a repeating collection of single value fields.');
  }
}

/**
 * Implementation of hook_views_api().
 */
function content_podgroup_views_api() {
  return array(
    'api' => 2,
    'path' => drupal_get_path('module', 'content_multigroup') . '/views',
  );
}

/**
 * Implementation of hook_ctools_plugin_directory().
 */
function content_podgroup_ctools_plugin_directory($module, $plugin) {
  if ($module == 'ctools' && $plugin == 'content_types') {
    return 'panels/' . $plugin;
  }
}

/**
 * Implementation of hook_menu().
 */
function content_podgroup_menu() {
  $items = array();
  // Callback for AHAH add more buttons.
  $items['content_podgroup/js_add_more'] = array(
    'page callback' => 'content_podgroup_add_more_js',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
    'file' => 'content_podgroup.node_form.inc',
  );
  return $items;
}

/**
 * Implementation of hook_theme().
 */
function content_podgroup_theme() {
  return array(
    'content_podgroup_node_form' => array(
      'arguments' => array('element' => NULL),
      'file' => 'content_podgroup.node_form.inc',
    ),
    'content_podgroup_node_label' => array(
      'arguments' => array('text' => NULL),
      'file' => 'content_podgroup.node_form.inc',
    ),
    'content_podgroup_display_simple' => array(
      'arguments' => array('element' => NULL),
      'file' => 'content_podgroup.node_view.inc',
    ),
    'content_podgroup_display_fieldset' => array(
      'arguments' => array('element' => NULL),
      'template' => 'content_podgroup',
      'file' => 'content_podgroup.node_view.inc',
    ),
    'content_podgroup_display_hr' => array(
      'arguments' => array('element' => NULL),
      'file' => 'content_podgroup.node_view.inc',
    ),
    'content_podgroup_display_table_single' => array(
      'arguments' => array('element' => NULL),
      'file' => 'content_podgroup.node_view.inc',
    ),
    'content_podgroup_display_table_multiple' => array(
      'arguments' => array('element' => NULL),
      'file' => 'content_podgroup.node_view.inc',
    ),
    'content_podgroup_display_wrapper' => array(
      'arguments' => array('element' => NULL, 'children' => NULL),
      'template' => 'content_podgroup',
      'file' => 'content_podgroup.node_view.inc',
    ),
    'content_podgroup' => array(
      'arguments' => array('element' => NULL, 'children' => NULL),
      'template' => 'content_podgroup',
      'file' => 'content_podgroup.node_view.inc',
    ),
    'content_podgroup_null' => array(
      'arguments' => array('element' => NULL),
      'file' => 'content_podgroup.node_view.inc',
    ),
    'content_podgroup_js_form' => array(
      'arguments' => array('form' => NULL, 'tree' => NULL),
      'file' => 'content_podgroup.node_form',
    ),
    'content_podgroup_block' => array(
      'arguments' => array('content' => NULL),
      'file' => 'content_podgroup.node_view.inc',
    ),
  );
}

/**
 * Implementation of hook_elements().
 */
function content_podgroup_elements() {
  // @todo: I commented this out and it didn't seem to affect anything.  Is this needed, or can we remove it? -Dale
  return array(
    'content_podgroup_display_fieldset' => array(
      '#value' => NULL, '#input' => TRUE
    ),
  );
}

/**
 * Implementation of hook_preprocess_page().
 */
function content_podgroup_preprocess_page(&$vars) {
  $content = array();
  $blocks = array();

  // These blocks can only show up on node view pages.
  // Get nid and vid if revisioned from url.
  $arg = arg(); // Reduce function calls to arg().
  if ($arg[0] == 'node' && is_numeric($arg[1])) {
    $node = content_podgroup_current_node();
    if (!empty($node)) {

      $query = "SELECT * FROM {content_podgroup_blocks} WHERE vid = %d";
      $result = db_query($query, $node->vid);
      while ($block_data = db_fetch_array($result)) {
        $type = $block_data['type'];
        $podgroup_delta = $block_data['podgroup_delta'];

        $branch = content_podgroup_load_branch($node, $type, $podgroup_delta);
        $pod = array();
        foreach ($branch as $pod) {
          if ($pod['parent_type'] == 'group_parent') {
            $parent = $pod;
            break;
          }
        }

        if (!empty($node->podgroups[$parent['theme']][$parent['region']])) {
          $num_pods = count($node->podgroups[$parent['theme']][$parent['region']]);

          $count = 0;
          foreach ($node->podgroups[$parent['theme']][$parent['region']] as $content_branch) {
            if ($content_branch['type'] == $parent['type'] && $content_branch['delta'] == $parent['delta']) {
              if ($count == 0) {
                $content_branch['element']['#attributes']['class'] .= empty($content_branch['element']['#attributes']['class']) ? 'first-pod' : ' first-pod';
              }
              if ($count == $num_pods - 1) {
                $content_branch['element']['#attributes']['class'] .= empty($content_branch['element']['#attributes']['class']) ? 'last-pod' : ' last-pod';
              }
              $content = content_podgroup_filter_up_nested_tree_content(array($content_branch));              
              break;
            }
            $count++;
          }
        }
        if (!empty($content)) {
          $content[0]['#node'] = $node;
          $block = new stdClass();
          $block->subject = t($branch[0]['title']);
          $block->content = theme('content_podgroup_block', $content[0]);
          $block->module = 'content_podgroup';
          $block->delta = $block_data['cpbid'];
          $block->region = $content[0]['#region'];
          $vars[$content[0]['#region']] .= theme('block', $block);
        }
      }
    }
  }
}

/**
 * Implementation of hook_nodeapi().
 */
function content_podgroup_nodeapi(&$node, $op, $teaser, $page) {
  switch ($op) {
    case 'view':
      // Prevent against invalid 'nodes' built by broken 3rd party code.
      if (isset($node->type)) {
        content_podgroup_build_podgroups($node);
      }
      break;

    case 'insert':
    case 'update':
      content_podgroup_save_podgroups($node);
      break;

    case 'delete':
    case 'delete revision':
      content_podgroup_delete_podgroups($node);
      break;
    case 'alter':
      content_podgroup_current_node($node);
      break;
  }
}

/**
 * Helper function for setting and getting the current node.
 *
 * The node has already bee rendered.
 *
 * @see content_podgroup_nodeapi()
 */
function content_podgroup_current_node($set_node = NULL) {
  static $node = NULL;
  if (!empty($set_node)) {
    $node = $set_node;
  }
  return $node;
}

/**
 * Save podgroups data to the database
 */
function content_podgroup_save_podgroups($node) {

  // The content module stops building the form if the type has no fields.
  $content_type = content_types($node->type);
  if (empty($content_type['fields'])) {
    return;
  }

  // Process podgroups and get them as a flattened tree.
  $new_list       = content_podgroup_extract_list_from_node($node);
  $delta_hash     = content_podgroup_remove_deleted_items($new_list);
  $new_tree       = content_podgroup_grow_tree_from_list($new_list);
  $flattened_tree = content_podgroup_flatten_tree($new_tree);

  // Make sure we have data to save before we remove the old data and save the new.
  foreach (content_podgroup_load_podgroups($node->type) as $group_name => $group) {
    if (!isset($node->$group_name) && !isset($node->podgroups)) {
      return;
    }
  }
  // Remove any of the old podgroup entries and blocks for this node.
  content_podgroup_delete_podgroups($node);

  $block_weight = 0;

  foreach ($flattened_tree as $item) {
    $query = "INSERT INTO {content_type_" . $node->type . "_podgroup} (vid, nid, type, delta, title, parent_type, parent_delta, region, theme, subpages, tt_left, tt_right) VALUES (%d, %d, '%s', %d, '%s', '%s', %d, '%s', '%s', %d, %d, %d)";
    db_query($query, $node->vid, $node->nid, $item['_type'], $item['_delta'], $item['_title'], $item['_parent_type'], $item['_parent_delta'], $item['_region'], $item['_theme'], $item['_subpages'], $item['_tt_left'], $item['_tt_right']);

    // If it is a parent podgroup, create a block for it
    if ($item['_parent_type'] == 'group_parent') {
      $pages = ('node/' . $node->nid);
      $pages .= "\nnode/" . $node->nid . "/revisions/*/view";
      if ($item['_subpages'] == 1) {
        $pages .= "\n$pages/*";
      }

      // Insert into block helper table.
      $query = "insert into {content_podgroup_blocks} (nid, vid, type, podgroup_delta) values(%d, %d, '%s', %d);";
      db_query($query, $node->nid, $node->vid, $item['_type'], $item['_delta']);
    }
  }
}

/**
 * create list of podgroups from node
 */
function content_podgroup_extract_list_from_node($node) {
  $new_list = array();

  $node_type = $node->type;
  foreach (content_podgroup_load_podgroups($node_type) as $group_name => $group) {
    $rebuild_index[$group_name] = FALSE;
    if (isset($node->$group_name)) {
      foreach ($node->$group_name as $old_idx => $item) {

        if (!is_array($item) || !isset($item['_weight'])) {
          continue;
        }

        $parent_info = explode('|', $item['_parent']);
        $item['_parent_type'] = $parent_info[0];
        $item['_parent_delta'] = $parent_info[1];
        $item['_type'] = $group_name;
        $item['_delta'] = $item['_weight'];
        $item['#children'] = array();

        if (empty($item['_theme'])) {
          $item['_theme'] = variable_get('theme_default', 'garland');
        }

        if (!isset($new_list[$item['_theme']])) {
          $new_list[$item['_theme']] = array();
        }
        if (!isset($new_list[$item['_theme']][$item['_region']])) {
          $new_list[$item['_theme']][$item['_region']] = array();
        }

        $new_list[$item['_theme']][$item['_region']][] = $item;
      }
    }
  }

  return $new_list;
}

/**
 * remove deleted items from $new_list and return $delta_hash
 */
function content_podgroup_remove_deleted_items(&$new_list) {
  // Remove items to be deleted from the list
  $delta_hash = array();
  $delta_hash['group_parent'] = array(0 => 0);
  foreach ($new_list as $theme => $regions) {
    foreach ($regions as $region => $podgroups) {
      foreach ($podgroups as $delta => $podgroup) {
        if ($podgroup['_remove']) {
          $parent_type = $podgroup['_type'];
          $parent_delta = $podgroup['_delta'];

          // Make sure childen will be deleted.
          foreach ($podgroups as $child_delta => $child_podgroup) {
            if ($child_podgroup['_parent_type'] == $parent_type && $child_podgroup['_parent_delta'] == $parent_delta) {
              unset($new_list[$theme][$region][$child_delta]);
            }
          }
          unset($new_list[$theme][$region][$delta]);
        }
        else {
          // Make sure this row hasn't been deleted already in the original list.
          if (!empty($new_list[$theme][$region][$delta])) {
            if (!isset($delta_hash[$podgroup['_type']])) {
              $delta_hash[$podgroup['_type']] = array();
            }
            $instance_delta = $new_list[$theme][$region][$delta]['_delta'];
            $delta_hash[$podgroup['_type']][] = $instance_delta;
          }
        }
      }
    }
  }

  // Compute the new deltas now that we have removed all the deleted podgroups
  foreach ($delta_hash as $type => $delta_array) {
    sort($delta_hash[$type], SORT_NUMERIC);
    $delta_hash[$type] = array_flip($delta_hash[$type]);
  }

  // Reset the deltas after we've removed the deleted podgroups
  foreach ($new_list as $theme => $regions) {
    foreach ($regions as $region => $podgroups) {
      // Collapse the array so that the index values are continuous
      $new_list[$theme][$region] = array_values($new_list[$theme][$region]);

      foreach ($new_list[$theme][$region] as $delta => $podgroup) {
        $new_list[$theme][$region][$delta]['_delta'] = $delta_hash[$podgroup['_type']][$podgroup['_delta']];
        $new_list[$theme][$region][$delta]['_parent_delta'] = $delta_hash[$podgroup['_parent_type']][$podgroup['_parent_delta']];
      }
    }
  }

  return $delta_hash;
}

/**
 * Take $new_tree and flatten it
 */
function content_podgroup_flatten_tree($new_tree) {
  // Convert $new_tree to flattened tree, reordering deltas and weights in the process
  $flattened_tree = array();
  $delta_hash = array();
  foreach ($new_tree as $theme => $regions) {
    foreach ($regions as $region => $podgroups) {
      $flattened_tree = array_merge_recursive($flattened_tree, content_podgroup_flatten_tree_to_list($podgroups));
    }
  }

  return $flattened_tree;
}

/**
 * Alter deltas of podgroup fields so they match the number of podgroup fields in this node
 * delta affects the size of the weight dropdowns
 */
function content_podgroup_form_alter_deltas(&$form) {
  // Get all the groups for this node type
  $content_type_fieldgroups = content_podgroup_load_podgroups($form['#node']->type);

  $count = 0;
  // Iterate over all the podgroups and count the number of podgroup elements in the form
  foreach ($content_type_fieldgroups as $group) {
    if ($group['group_type'] == 'podgroup') {
      foreach ($form[$group['group_name']] as $key => $row) {
        if (is_numeric($key)) {
          $count++;
        }
      }
    }
  }

  // If count > 0, aka there are podgroups in this form, then update the deltas to range from -count to count
  if ($count > 0) {
    foreach($content_type_fieldgroups as $group) {
      if ($group['group_type'] == 'podgroup') {
        foreach($form[$group['group_name']] as $key => $row) {
          if (is_numeric($key)) {
            $form[$group['group_name']][$key]['_weight']['#delta'] = $count;
            $form[$group['group_name']][$key]['_weight']['#options'] = array();
            for ($i = -$count; $i <= $count; $i++) {
              $form[$group['group_name']][$key]['_weight']['#options'][$i] = $i;
            }
          }
        }
      }
    }
  }
}

/**
 * Implementation of hook_form_alter().
 */
function content_podgroup_form_alter(&$form, $form_state, $form_id) {

  switch ($form_id) {
    case 'content_field_edit_form':
      if (isset($form['widget'])) {
        // If this is a field edit form and the field is in a Multigroup,
        // override the multiple value settings.
        $content_type = content_types($form['type_name']['#value']);
        $groups = fieldgroup_groups($content_type['type']);
        $group_name = _fieldgroup_field_get_group($content_type['type'], $form['field_name']['#value']);
        $group = isset($groups[$group_name]) ? $groups[$group_name] : array();
        if (!empty($group) && $group['group_type'] == 'podgroup') {
          $form['field']['multiple']['#value'] = TRUE;
          $form['field']['multiple']['#access'] = FALSE;
        }
      }
      elseif (isset($form_state['change_basic'])) {
        // This is the basic field settings form. It should not be possible to
        // choose a widget type that is not compatible with multigroups.
        module_load_include('inc', 'content_podgroup', 'content_podgroup.admin');
        content_podgroup_field_basic_form($form, $form_state);
      }
      break;

    case 'content_field_overview_form':
      // Validation for creating/moving fields and groups on the
      // Manage Fields screen.
      module_load_include('inc', 'content_podgroup', 'content_podgroup.admin');
      $form['#validate'][] = 'content_podgroup_field_overview_form_validate';
      $form['#submit'][] = 'content_podgroup_field_overview_form_submit';
      break;

    case 'content_display_overview_form':
      if (!empty($form['#groups'])) {
        // Add an additional selector for setting podgroup field display
        // format to the Display Fields screen.
        module_load_include('inc', 'content_podgroup', 'content_podgroup.admin');
        content_podgroup_display_overview_form($form, $form_state);
      }
      break;

    case 'fieldgroup_group_edit_form':
      // Alter the Fieldgroup edit form to add Pod settings.
      module_load_include('inc', 'content_podgroup', 'content_podgroup.admin');
      content_podgroup_group_edit_form($form, $form_state);
      break;

    case $form['#node']->type . '_node_form':
      // We need these for ahah functions that might later get added dynamically themselves
      drupal_add_js('misc/jquery.form.js');
      drupal_add_js('misc/ahah.js');

      // Workaround bug that makes filters display when no body is used
      if (empty($form['body_field']['body'])) {
        unset($form['body_field']);
      }

      if (!empty($form['#podgroups'])) {
        content_podgroup_form_alter_deltas($form);
        _content_podgroup_node_form_add_js($form);
        $form['podgroup_js'] = array('#value' => '<div id="podgroup-js-table"></div>');
      }
      break;

    case 'fieldgroup_remove_group':
      $form['#submit'][] = 'content_podgroup_fieldgroup_remove_group_form_submit';
      break;

    case 'node_type_delete_confirm':
      $form['#submit'][] = 'content_podgroup_node_type_delete_confirm';
      break;
    case 'node_revision_revert_confirm':
      $form['#submit'][] = 'content_podgroup_node_revision_revert_confirm';
      break;
    case 'block_admin_display_form':
      // Remove podgroup blocks from form so they don't get displayed on the blocks admin page
      foreach ($form as $key => $row) {
        if (!empty($row['module']['#value']) && $row['module']['#value'] == 'content_podgroup') {
          unset($form[$key]);
        }
      }
      break;
    case 'ctools_export_ui_edit_item_form':
    case 'ctools_export_ui_edit_item_wizard_form':
      // Remove podgroup blocks from context_ui_form
      if (preg_match('/^context_ui_form$/', $form['#base'])) {
        if (isset($form['reactions']['plugins']['block']['selector']['content_podgroup'])) {
          unset($form['reactions']['plugins']['block']['selector']['content_podgroup']);
        }
      }
      break;
  }

}

/**
 * hook_submit addition for node_revision_revert_confirm form
 * revert podgroups to previous version
 */
function content_podgroup_node_revision_revert_confirm($form, &$form_state) {

  $old_vid = $form['#node_revision']->old_vid;
  $new_vid = $form['#node_revision']->vid;

  $sql = "INSERT INTO {content_type_page_podgroup}(nid, vid, type, delta, title, parent_type, parent_delta, region, theme, subpages, tt_left, tt_right)
          SELECT nid, %d, type, delta, title, parent_type, parent_delta, region, theme, subpages, tt_left, tt_right
          FROM {content_type_page_podgroup}
          WHERE vid = %d";
  db_query($sql, $new_vid, $old_vid);

  $sql = "INSERT INTO {content_podgroup_blocks}(nid, vid, type, podgroup_delta)
          SELECT nid, %d, type, podgroup_delta
          FROM {content_podgroup_blocks}
          WHERE vid = %d;";
  db_query($sql, $new_vid, $old_vid);
}

/**
 * Submit function for removing podgroups.
 * Check to see if we need to drop the _podgroups table.
 */
function content_podgroup_fieldgroup_remove_group_form_submit($form, &$form_state) {

  // Delete rows for podgroup in blocks on podgroup tables.
  content_podgroup_delete_fieldgroup($form['#content_type']['type'], $form['#group_name']);

  // Drop podgroup table if this is the last podgroup in the type.
  content_podgroup_delete_podgroup_table($form['#content_type']['type'], $form['#group_name']);
}

/**
 * Delete rows for podgroup in blocks on podgroup tables.
 */
function content_podgroup_delete_fieldgroup($content_type, $group) {
  // Delete from content_podgroup_blocks
  $sql = "DELETE cpb
          FROM {content_type_%s_podgroup} p
          JOIN {node} n on n.vid = p.vid
          JOIN {content_podgroup_blocks} cpb on cpb.vid = n.vid
            and cpb.type = p.type
            and cpb.podgroup_delta = p.delta
          WHERE p.type = '%s'
          and n.type = '%s';";
  db_query($sql, $content_type, $group, $content_type);

  // Delete from content_type_[TYPE]_podgroup
  $sql = "DELETE p
          FROM {content_type_%s_podgroup} p
          JOIN {node} n on n.vid = p.vid
          WHERE p.type = '%s'
          and n.type = '%s';";
  db_query($sql, $content_type, $group, $content_type);

}

/**
 * Drop podgroup table if this is the last podgroup in the type.
 */
function content_podgroup_delete_podgroup_table($content_type, $group) {
  // Assume we will do the delete
  $do_delete = true;

  // Check if we really want to do delete.
  // We don't if there is a podgroup in this content type that doesn't match the one we deleted
  $content_type_fieldgroups = content_podgroup_load_podgroups($content_type);
  foreach ($content_type_fieldgroups as $curr_group) {
    if ($curr_group['group_name'] != $group) {
      $do_delete = false;
    }
  }

  // Delete the table
  if ($do_delete) {
    $ret = array();
    db_drop_table($ret, 'content_type_' . $content_type . '_podgroup');
  }
}

/**
 * Submit function for node_type_delete_confirm form.
 */
function content_podgroup_node_type_delete_confirm($form, &$form_state) {
  // If this content type has a podgroups table, drop the table
  $podgroup_table_name = 'content_type_' . $form_state['values']['type'] . '_podgroup';
  $query = "show tables like '$podgroup_table_name'";
  $result = db_query($query);

  if (db_affected_rows($result) > 0) {
    $ret = array();
    db_drop_table($ret, $podgroup_table_name);
  }
}

/**
 * After build callback for multigroups in node form (Runs before anything else).
 *
 * This proxy function is necessary to prevent from breaking AHAH handlers.
 */
function content_podgroup_node_form_after_build($form, &$form_state) {
  module_load_include('inc', 'content_podgroup', 'content_podgroup.node_form');
  $form = _content_podgroup_compute_nesting_options($form, $form_state);
  $form = _content_podgroup_node_form_after_build($form, $form_state);

  if (!empty($form['#podgroups'])) {
    content_podgroup_form_alter_deltas($form);
  }

  return $form;
}

/**
 * After build callback for multigroups in node form (Runs at the very end).
 *
 * Remove all the placeholder fields we were using to ensure modules added
 * the necessary files such as js, css, etc.
 */
function content_podgroup_node_form_after_build_remove_temp($form, &$form_state) {
  drupal_render($form['podgroups_temp']);

  return $form;
}

/**
 * Implementation of hook_fieldgroup_view().
 */
function content_podgroup_fieldgroup_view(&$node, &$element, $group, $context) {
  module_load_include('inc', 'content_podgroup', 'content_podgroup.node_view');
  if ($group['group_type'] == 'podgroup') {
    _content_podgroup_fieldgroup_view($node, $element, $group, $context);
  }
}

/**
 * Implementation of hook_fieldgroup_form().
 */
function content_podgroup_fieldgroup_form(&$form, &$form_state, $form_id, $group) {
  $group_name = $group['group_name'];
  if ($group['group_type'] == 'podgroup' && !empty($form[$group_name])) {
    if (!isset($form[$group_name]['#access']) || $form[$group_name]['#access']) {
      module_load_include('inc', 'content_podgroup', 'content_podgroup.node_form');
      $form[$group_name]['#attributes']['class'] .= ' podgroup';
      _content_podgroup_fieldgroup_form($form, $form_state, $form_id, $group);
    }
  }
}

/**
 * Implementation of hook_fieldgroup_types().
 */
function content_podgroup_fieldgroup_types() {
  return array('podgroup' => t('Podgroup'));
}

/**
 * Implementation of hook_fieldgroup_default_settings().
 */
function content_podgroup_fieldgroup_default_settings($group_type) {
  if ($group_type == 'podgroup') {
    module_load_include('inc', 'content', 'includes/content.admin');
    $settings = array(
      'form' => array(
        'style' => 'content_podgroup_display_wrapper',
      ),
      'podgroup' => array(
        'nesting' => array('group_parent' => TRUE),
        'regions' => array('content' => TRUE),
      )
    );
    foreach (array_keys(content_build_modes()) as $key) {
      $settings['display'][$key]['format'] = 'content_podgroup_display_wrapper';
    }
    return $settings;
  }
}

/**
 * Implementation of hook_fieldgroup_save().
 */
function content_podgroup_fieldgroup_save($group) {
  if ($group['group_type'] == 'podgroup') {
    module_load_include('inc', 'content_podgroup', 'content_podgroup.admin');
    _content_podgroup_fieldgroup_save($group);
  }
}

function strip_posts($form) {
  if (is_array($form)) {
    foreach ($form as $key => $value) {
      if ($key === '#post') {
        unset($form[$key]);
      }
      else {
        $form[$key] = strip_posts($value);
      }
    }
  }
  return $form;
}

function content_podgroup_extract_list_from_form_state($form, $form_state) {
  $new_list = array();

  $node_type = $form['#node']->type;
  foreach (content_podgroup_load_podgroups($node_type) as $group_name => $group) {
    $rebuild_index[$group_name] = FALSE;
    if (isset($form_state['values'][$group_name])) {
      foreach ($form_state['values'][$group_name] as $old_idx => $item) {

        if (!is_array($item) || !isset($item['_weight'])) {
          continue;
        }

        $parent_info = explode('|', $item['_parent']);
        $item['_parent_type'] = $parent_info[0];
        $item['_parent_delta'] = $parent_info[1];
        $item['_type'] = $group_name;
        $item['_delta'] = $item['_weight'];
        $item['#children'] = array();

        if (empty($item['_theme'])) {
          $item['_theme'] = variable_get('theme_default', 'garland');
        }

        if (!isset($new_list[$item['_theme']])) {
          $new_list[$item['_theme']] = array();
        }
        if (!isset($new_list[$item['_theme']][$item['_region']])) {
          $new_list[$item['_theme']][$item['_region']] = array();
        }

        $new_list[$item['_theme']][$item['_region']][] = $item;
      }
    }
  }

  return $new_list;
}

/**
 * Deletes all podgroups for given node.
 */
function content_podgroup_delete_podgroups($node) {

  // Make sure this content type has podgroups before deleting
  if (count(content_podgroup_load_podgroups($node->type)) > 0) {

    // Remove any of the old podgroup entries for this node
    db_query("DELETE FROM {content_type_" . $node->type . "_podgroup} WHERE vid = %d", $node->vid);

    // Remove any rows from content_podgroup_blocks.
    db_query("delete from {content_podgroup_blocks} where vid = %d;", $node->vid);
  }
}

/**
 * Retrieves a podgroup instance from the podgroup tree.
 *
 * Retrieves a podgroup instance form the podgroup tree.  Why would you use this instead of
 * querying the database? Because this computes the weight field and it is heavily cached so
 * it isn't too expensive.
 */
function content_podgroup_find_in_tree($node, $group_name, $delta) {
  $podgroup = array();

  $tree = content_podgroup_load_tree($node);

  $flattened_tree = array();
  if ($tree) {
    foreach ($tree as $theme => $regions) {
      foreach ($regions as $region => $podgroups) {
        $flattened_tree = array_merge_recursive($flattened_tree, content_podgroup_flatten_tree_to_list($podgroups));
      }
    }

    foreach ($flattened_tree as $item) {
      if ($item['type'] == $group_name && $item['delta'] == $delta) {
        $podgroup = $item;
        break;
      }
    }
  }

  return $podgroup;
}

/**
 * Retrieves a podgroup instance from the podgroup tree.
 *
 * Retrieves a podgroup instance form the podgroup tree.  Why would you use this instead of
 * querying the database? Because this computes the weight field and it is heavily cached so
 * it isn't too expensive.
 */
function content_podgroup_find_in_form_state($form, $form_state, $group_name, $delta) {
  $podgroup = array();

  $form_state_list = content_podgroup_extract_list_from_form_state($form, $form_state);

  $tree = content_podgroup_grow_tree_from_list($form_state_list);

  $flattened_tree = array();
  foreach ($tree as $theme => $regions) {
    foreach ($regions as $region => $podgroups) {
      $flattened_tree = array_merge_recursive($flattened_tree, content_podgroup_flatten_tree_to_list($podgroups));
    }
  }

  foreach ($flattened_tree as $item) {
    if ($item['_type'] == $group_name && $item['_delta'] == $delta) {
      $podgroup = $item;
      break;
    }
  }

  return $podgroup;
}

/**
 * Flattens a tree into a list
 */
function content_podgroup_flatten_tree_to_list(&$tree) {
  $list = array();

  for ($i = 0; $i < count($tree); $i++) {
    if (!empty($tree[$i]['#children'])) {
      $children_list = content_podgroup_flatten_tree_to_list($tree[$i]['#children']);
      $list = array_merge_recursive($list, $children_list);
      unset($tree[$i]['#children']);
    }
    $list[] = $tree[$i];

  }

  return $list;
}

/**
 * Helper function to recursively build a tree
 */
function _content_podgroup_grow_tree_from_list_recursion(&$podgroups, $parent_key, $parent_item) {
  $local_copy = $podgroups;
  foreach ($local_copy as $item_key => $item_value) {
    // Foreach seems to cache the keys at the beginning so we have to check to see if we have unset the key it is using to iterate
    if (!isset($podgroups[$item_key])) {
      continue;
    }

    // If $item is the $parent_item then continue since we don't want to set it as a child of itself
    if ($item_key == $parent_key) {
      continue;
    }

    if ($item_value['_parent_type'] == $parent_item['_type'] && $item_value['_parent_delta'] == $parent_item['_delta']) {
      $item_value = _content_podgroup_grow_tree_from_list_recursion($podgroups, $item_key, $item_value);

      if (!isset($parent_item['#children'])) {
        $parent_item['#children'] = array();
      }

      // Loop through parent's(j) children and find insert_index of current child podgroup(i) base on _weight
      $num_of_children = count($parent_item['#children']);
      for ($insert_index = 0; $insert_index < $num_of_children; $insert_index++) {
        if ($parent_item['#children'][$insert_index]['_submitted_weight'] > $podgroups[$item_key]['_submitted_weight']) {
          break;
        }
      }

      // Get all children before insert_index
      $first_half = array_slice($parent_item['#children'], 0, $insert_index);

      // If not inserting at end, get children after insert_index
      if ($insert_index < count($parent_item['#children'])) {
        $second_half = array_slice($parent_item['#children'], $insert_index);
      }
      else {
        $second_half = array();
      }

      // Create children array and set the parents children to this
      $children = array();
      foreach ($first_half as $child) {
        $children[] = $child;
      }
      $children[] = $item_value;
      foreach ($second_half as $child) {
        $children[] = $child;
      }
      $parent_item['#children'] = $children;

      unset($podgroups[$item_key]);
    }
  }

  return $parent_item;
}

/**
 * Builds a tree from a list.
 *
 * Builds a tree from a list assuming the array keys are ascending and consecutive integer values starting with 0.
 */
function content_podgroup_grow_tree_from_list($new_tree) {
  foreach ($new_tree as $theme => $regions) {
    foreach ($regions as $region => $podgroups) {
      foreach ($podgroups as $item_key => $item_value) {
        // Foreach seems to cache the keys at the beginning so we have to check to see if we have unset the key it is using to iterate
        if (!isset($podgroups[$item_key])) {
          continue;
        }

        if ($item_value['_parent_type'] == 'group_parent' && $item_value['_parent_delta'] == 0) {
          $podgroups[$item_key] = _content_podgroup_grow_tree_from_list_recursion($podgroups, $item_key, $item_value);
        }
      }

      // By now the tree is ordered, execpt for the top level, we must reorder that
      usort($podgroups, 'content_podgroup_sort_tree_array');

      // Reset the array's indexes
      $podgroups = array_values($podgroups);
      preorder_tree_traversal_calc($podgroups);
      $regions[$region] = $podgroups;
    }
    $new_tree[$theme] = $regions;
  }

  return $new_tree;
}

/**
 * Sorting function for use by usort
 */
function content_podgroup_sort_tree_array($a, $b) {
  return $a['_submitted_weight'] - $b['_submitted_weight'];
}

/**
 * Add the tt_left and tt_right values for the tree
 * this assumes the array is already in the correct order
 */
function preorder_tree_traversal_calc(&$tree, $tt_val = 1) {
  $tree_size = count($tree);
  for ($i = 0; $i < $tree_size; $i++) {
    $tree[$i]['_tt_left'] = $tt_val++;

    if (!empty($tree[$i]['#children'])) {
      $tt_val = preorder_tree_traversal_calc($tree[$i]['#children'], $tt_val);
    }

    $tree[$i]['_tt_right'] = $tt_val++;
  }
  return $tt_val;
}


/**
 * Load podgroup tree
 */
function content_podgroup_load_tree($node, $reset = FALSE) {
  static $tree;

  $nid = $node->clone_from_original_nid ? $node->clone_from_original_nid : $node->nid;

  if (!is_array($tree) || $reset == TRUE) {
    // If the tree hasn't been initialized, initialize it first.
    $tree = array();
  }

  if (is_array($tree) && isset($tree[$nid]) && $reset == FALSE) {
    // If we have the tree in the local memory, just return it.
    return $tree[$nid];
  }
  else {
    // Otherwise we want to attempt to fetch it from cache.
    // $tree_cache = cache_get('podgroup_tree_' . $nid);
    if (!empty($tree_cache->data) && $reset == FALSE) {
      $tree[$nid] = $tree_cache->data;
    }
    else {
      // If not in cache or static tree, we want to grab it from the database.
      $list = content_podgroup_load_all($node);

      // Sort podgroups by theme and region
      $sorted_list = array();
      foreach ($list as $item) {
        if (!isset($sorted_list[$item['theme']])) {
          $sorted_list[$item['theme']] = array();
        }
        if (!isset($sorted_list[$item['theme']][$item['region']])) {
          $sorted_list[$item['theme']][$item['region']] = array();
        }
        $sorted_list[$item['theme']][$item['region']][] = $item;
      }

      // Loop through all the themes and their regions and build each of their trees
      foreach ($sorted_list as $theme => $regions) {
        foreach ($regions as $region => $pod_list) {
          // Sort array by tt_left asc in preparation of building the tree
          usort($pod_list, '_content_podgroup_sort_flattened_tree');
          // Build the tree so that we can pop the rendered podgroups into their parent's 'children' property
          $pod_list_tree = content_podgroup_build_tree($pod_list);

          if (!isset($tree[$nid][$theme])) {
            $tree[$nid][$theme] = array();
          }
          $tree[$nid][$theme][$region] = $pod_list_tree;
        }
      }

      cache_set('podgroup_tree_' . $nid, $tree);
    }
  }
  return $tree[$nid];
}

/**
 * Builds a nested tree array from a list array, list must include tt_left and tt_right keys.
 */
function content_podgroup_build_tree(&$list, $right = NULL) {
  $tree = array();

  for ($i = 0; $row = array_shift($list); $i++) {
    if ($row['tt_right'] - $row['tt_left'] != 1) {
      $row['#children'] = content_podgroup_build_tree($list, $row['tt_right']);
    }

    $row['weight'] = $i;
    $tree[] = $row;

    if ($right != NULL && $right - $row['tt_right'] == 1) {
      break;
    }
  }

  return $tree;
}

/**
 * Get a list of all the podgroups.
 */
function content_podgroup_load_podgroups($type = NULL, $sorted = FALSE, $reset = FALSE) {
  static $cache = array();

  if (!isset($cache[($sorted ? 'sorted' : 'unsorted')][$type]) || $reset) {
    $podgroups = array();

    foreach (fieldgroup_groups($type, $sorted, $reset) as $group) {
      if ($group['group_type'] == 'podgroup') {
        $podgroups[$group['group_name']] = $group;
      }
    }

    if (!isset($cache[($sorted ? 'sorted' : 'unsorted')])) {
      $cache[($sorted ? 'sorted' : 'unsorted')] = array();
    }

    $cache[($sorted ? 'sorted' : 'unsorted')][$type] = $podgroups;
  }

  return $cache[($sorted ? 'sorted' : 'unsorted')][$type];
}

/**
 * Get the group additional attributes.
 */
function content_podgroup_load_all($node) {

  // Load vid checking if we are cloning or not
  $vid = ($node->clone_from_original_vid) ? $node->clone_from_original_vid : $node->vid;

  $return = array();
  $result = db_query(
    "SELECT
       nid,
       vid,
       type,
       delta,
       title,
       parent_type,
       parent_delta,
       region,
       theme,
       subpages,
       tt_left,
       tt_right
     FROM {content_type_" . $node->type . "_podgroup}
     WHERE vid = %d
     ORDER BY tt_left ASC", $vid);
  while ($item = db_fetch_array($result)) {
    $return[] = $item;
  }

  return $return;
}

/**
 * Get the group entries for a given branch of the group tree.
 */
function content_podgroup_load_branch($node, $type, $delta) {
  $return = array();
  $result = db_query(
    "SELECT
       ctxp_child.nid,
       ctxp_child.vid,
       ctxp_child.type,
       ctxp_child.delta,
       ctxp_child.title,
       ctxp_child.parent_type,
       ctxp_child.parent_delta,
       ctxp_child.region,
       ctxp_child.theme,
       ctxp_child.subpages,
       ctxp_child.tt_left,
       ctxp_child.tt_right
     FROM {content_type_" . $node->type . "_podgroup} as ctxp_parent
     JOIN {content_type_" . $node->type . "_podgroup} as ctxp_child ON ctxp_child.vid = ctxp_parent.vid
     WHERE ctxp_parent.vid = %d AND ctxp_parent.type = '%s' AND ctxp_parent.delta = %d AND ctxp_child.tt_left >= ctxp_parent.tt_left AND ctxp_child.tt_right <= ctxp_parent.tt_right AND ctxp_child.region = ctxp_parent.region
     ORDER BY ctxp_child.tt_left ASC", $node->vid, $type, $delta);
  while ($item = db_fetch_array($result)) {
    $return[] = $item;
  }
  return $return;
}

/**
 * Get the group additional attributes.
 */
function content_podgroup_load_group($node, $group_name, $delta) {
  $result = db_query(
    "SELECT parent_type,
       parent_delta,
       region,
       theme,
       subpages,
       title
     FROM {content_type_" . $node->type . "_podgroup}
     WHERE type = '%s' AND delta = %d AND nid = %d AND vid = %d ", $group_name, $delta, $node->nid, $node->vid);
  return db_fetch_array($result);
}

/**
 * Build the podgroups.
 */
function content_podgroup_build_podgroups(&$node) {
  static $cache = array();

  $cache_key = $node->nid;

  if (isset($cache[$cache_key])) {
    $node = drupal_clone($cache[$cache_key]);
  }
  else {
    // Build the node content element needed to render each podgroup.
    $podgroups = content_podgroup_load_podgroups($node->type);

    if (!empty($podgroups)) {
      // On pass two we want to rebuild the grouped fields into a podgroup.
      $podgroups_instances_list = content_podgroup_load_all($node);

      $list = $podgroups_instances_list;
      $list_processed = array();

      // Add the rendered podgroup to the podgroup list so that we can build the tree
      foreach ($node->content as $field_name => $field) {
        if (array_key_exists($field_name, $podgroups)) {
          foreach ($field['group'] as $delta => $podgroup_instance) {
            if (is_numeric($delta)) {
              foreach ($list as $key => $item) {
                if ($item['type'] == $field_name && $item['delta'] == $delta) {
                  $item['element'] = $podgroup_instance;
                  $item['element']['#title'] = $item['title'];

                  if (!isset($list_processed[$item['theme']])) {
                    $list_processed[$item['theme']] = array();
                  }
                  if (!isset($list_processed[$item['theme']][$item['region']])) {
                    $list_processed[$item['theme']][$item['region']] = array();
                  }
                  $list_processed[$item['theme']][$item['region']][] = $item;

                  unset($list[$key]);
                  break;
                }
              }

              unset($node->content[$field_name]['group'][$delta]);
            }
          }
          unset($node->content[$field_name]);
        }
      }

      $node->podgroups = array();
      foreach ($list_processed as $theme => $regions) {
        foreach ($regions as $region => $pod_list) {
          // Sort array by tt_left asc in preparation of building the tree
          usort($pod_list, '_content_podgroup_sort_flattened_tree');

          // Build the tree so that we can pop the rendered podgroups into their parent's 'children' property
          $pod_list_tree = content_podgroup_build_tree($pod_list);

          if (!isset($node->podgroups[$theme])) {
            $node->podgroups[$theme] = array();
          }
          $node->podgroups[$theme][$region] = $pod_list_tree;
        }
      }
    }
    $cache[$cache_key] = drupal_clone($node);
  }
}

/**
 * A little function to use in usort to sort flattened trees by tt_left
 */
function _content_podgroup_sort_flattened_tree($a, $b) {
  if ($a['tt_left'] == $b['tt_left']) {
    return 0;
  }
  return ($a['tt_left'] < $b['tt_left']) ? -1 : 1;
}

/**
 * Convert nested tree array tree into an array ready for node output
 */
function content_podgroup_filter_up_nested_tree_content($tree, $parent_element = NULL) {
  $list = array();
  $tree_size = count($tree);
  for ($i = 0; $i < $tree_size; $i++) {
    if (!empty($tree[$i]['#children'])) {
      $child_element = content_podgroup_filter_up_nested_tree_content($tree[$i]['#children'], $tree[$i]['element']);
      $tree[$i]['element']['children'] = $child_element;
      $tree[$i]['element']['children']['#weight'] = count($tree[$i]['element']);
      unset($tree[$i]['#children']);
    }
    $tree[$i]['element']['#region'] = $tree[$i]['region'];
    $tree[$i]['element']['#weight'] = $i;
    if ($parent_element) {
      $tree[$i]['element']['#parent'] = $parent_element;
      if ($i == 0) {
        $tree[$i]['element']['#attributes']['class'] .= ' first-child';
      }
      if ($i == $tree_size - 1) {
        $tree[$i]['element']['#attributes']['class'] .= ' last-child';
      }
    }

    $list[] = $tree[$i]['element'];
  }

  return $list;
}

/**
 * Implentation of hook_clone_node_alter().
 */
function content_podgroup_clone_node_alter(&$node, $original_node, $method) {
  // We use the original vid, so make sure we have access to it
  $node->clone_from_original_nid = $original_node->nid;
  $node->clone_from_original_vid = $original_node->vid;
}
